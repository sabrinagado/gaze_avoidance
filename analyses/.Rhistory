hrModProblems = which(allHrMod < minHrChange & lead(allHrMod) > 1/minHrChange) + 1 #rpeaks AFTER these indices are missing
}
}
# Save positions of R-peaks
out = data.frame(rpeaks = allrpeak)
write.csv2(out, code %>% paste0(path.rpeaks, ., path.rpeaks.postfix), row.names=FALSE, quote=FALSE)
dev.off()
}
scorest
scoreen
head(marker, 1)
# MAIN --------------------------------------------------------------------
index = 0
while(T) {
prompt = readline(paste0("Proceed with subject number: ", index+1, "? (Type \"n\" to select subject from list) "))
index = ifelse(prompt %>% substring(1, 1) == "n", promptIndex(codes.ecg), index+1)
if (index > length(codes.ecg)) {
print("Reached end of subject list. Exiting script.")
break
}
#for (index in seq(subjects.ecg)) {
subject = subjects.ecg[index]
code = codes.ecg[index]
code %>% paste0("Subject: ", .) %>% print()
print("Loading data...")
#external window (needed for script!)
x11()
par(mar=c(2,4,1,1))
layout(matrix(c(1,2),nrow=2), heights=c(2,1))
mainWindow = dev.cur()
if (exists("r.threshold")) rm("r.threshold") #clear subject threshold
# Load & Prepare Data -----------------------------------------------------
# Relevante Variablen:
# - ecg
# - timeline
# - marker (markertime)
if (unzipFiles) code %>% paste0(".zip") %>% unzip(exdir=path.phys)
#data = read.phys(subject)
data = read.table(subject ,col.names=c("timeline", "ECG", "Trigger"))
if (unzipFiles) subject %>% file.remove()
ecg = data$ECG
ecg[is.na(ecg)] = 0  # Remove NA
timeline = data$timeline     # in Sekunden
data = data %>% mutate(Trigger = ifelse(Trigger <= 8, Trigger, 0))
mst = data$Trigger %>% diff() %>% {. > 0} %>% which() %>% {. + 1}
if (length(mst)==0) mst = c(1, nrow(data)) #if no triggers present, score all data
if (exclusions.phys.trials[[code]] %>% is.null() == F) {
print(paste0("Manually excluding trials: ", paste0(exclusions.phys.trials[[code]], collapse = ", ")))
mst = mst[-exclusions.phys.trials[[code]]]
}
mst = mst %>% tail(trials.n)
marker = timeline[mst]
# Restrict range to majority of data
if (limitrange) {
ecg[ecg < quantile(ecg,plimit)] = quantile(ecg, plimit)
ecg[ecg > quantile(ecg,1-plimit)] = quantile(ecg, 1-plimit)
}
data$ECG = signal::filtfilt(ecg.filter, ecg) #filtering
rm(ecg)
# R Scoring -------------------------------------------------------------
# Restrict scoring range
scorest = {head(marker, 1) + min(analysis.range)} %>% c(0) %>% max()
scoreen = {tail(marker, 1) + max(analysis.range)} %>% c(tail(timeline, 1)) %>% min()
analysis.sequence = seq(scorest, scoreen, segment.length)
if (scorest == 0) warning(paste0(code, ": Too little time at the START of subject."))
if (scoreen == tail(timeline, 1)) warning(paste0(code, ": Too little time at the END of subject."))
# Determine peak detection threshold and find rpeaks adaptively for successive time windows
print(paste0("Analyzing data: (", round(scorest/60, 2), " - ", round(scoreen/60, 2), " min)"))
allrpeak.list = list() #very important if there is an old list (previous subject) that is longer than the current analysis segment length
if (code %>% paste0(path.rpeaks, ., path.rpeaks.postfix) %>% file.exists()) { #r peaks exist. Load them from file.
print("R peaks file detected.")
allrpeak = read.csv2(code %>% paste0(path.rpeaks, ., path.rpeaks.postfix))[, 1]
allrpeak.list = list()
for (i in seq(analysis.sequence)) {
st = analysis.sequence[i]
en = {st + segment.length} %>% c(max(timeline)) %>% min()
allrpeak.list[[toString(i)]] = allrpeak[allrpeak >= st & allrpeak < en]
}
} else if (exists("allrpeak")) rm(allrpeak)
manualok = FALSE
reassign = F
i = 1
finishFlag = F
while (i <= length(analysis.sequence) && !finishFlag) {
windowtxt = paste0(i, " of ", length(analysis.sequence))
if (exists("r.threshold_new")) rm("r.threshold_new")
st = analysis.sequence[i]
en = {st + segment.length} %>% c(max(timeline)) %>% min()
timewind = timeline[timeline>=st & timeline<en]
ecgwind  = data$ECG[timeline>=st & timeline<en]
markerwind = marker  [marker>=st &   marker<en]
#allrpeak.list needs to be filled a priori since finish command can be prompted, i.e. not all segments are visited and previous file would be shrunken down to visited segments
# if (exists("allrpeak")) {
#   rpeak.temp = allrpeak[allrpeak[, 1] >= st & allrpeak[, 1] < en, 1] #take rpeaks of current segment from allrpeak
#   if (length(rpeak.temp) > 0) allrpeak.list[[toString(i)]] = rpeak.temp
# }
if (allrpeak.list[[toString(i)]] %>% is.null() %>% !. && !reassign) { #this can also be reached from a "back" prompt even though allrpeak does not exist
rpeak = allrpeak.list[[toString(i)]]
hrtrial = 60/diff(rpeak)
# print("rpeaks read 1")
} else { #no r peaks in this segment, detect them
#does threshold exist? if not, create one
if (!exists("r.threshold")) {
r.threshold.initial = 1
while (r.threshold.initial==1 || min(hrtrial) < minhr) { # Successively lower threshold until minimum plausible heart rate is found ##TODO: this could go in a separate function with while loop below
r.threshold.old = as.numeric(quantile(ecgwind, r.threshold.initial)) #determine threshold as upper percentil of time series
r.threshold.initial = r.threshold.initial - 0.01
r.threshold = as.numeric(quantile(ecgwind, r.threshold.initial)) #determine threshold as upper percentil of time series
rpeak = timewind[findpeaks(ecgwind, r.threshold)]
# print("rpeaks created 1")
hrtrial = 60/diff(rpeak)
rpeak.old = timewind[findpeaks(ecgwind, r.threshold.old)]
hrtrial.old = 60/diff(rpeak.old)
#compare number of implausible values
if(length(rpeak.old) > 1 && implausibility(hrtrial) > implausibility(hrtrial.old)) {
r.threshold.initial = r.threshold.initial + 0.01
r.threshold = r.threshold.old #keep old threshold (fewer mistakes)
break
}
}
}
#apply threshold
rpeak = timewind[findpeaks(ecgwind, r.threshold)]
# print("rpeaks created 2")
hrtrial = 60/diff(rpeak)
#check for plausibility
if (min(hrtrial) < minhr || max(hrtrial) > maxhr) { #note: if the while loop would start here, you might get stuck in endless loop (e.g. 99% threshold < minHR but 98% threshold > maxHR)
if (max(hrtrial) > maxhr) r.threshold.initial = 1 #reset threshold to 1 if maxhr is exceeded
while (r.threshold.initial==1 || min(hrtrial) < minhr) { # Successively lower threshold until minimum plausible heart rate is found ##TODO: this could go in a separate function with while loop above
r.threshold.old = as.numeric(quantile(ecgwind, r.threshold.initial)) #determine threshold as upper percentil of time series
r.threshold.initial = r.threshold.initial - 0.01
r.threshold = as.numeric(quantile(ecgwind, r.threshold.initial)) #determine threshold as upper percentil of time series
rpeak = timewind[findpeaks(ecgwind, r.threshold)]
# print("rpeaks created 3")
hrtrial = 60/diff(rpeak)
rpeak.old = timewind[findpeaks(ecgwind, r.threshold.old)]
hrtrial.old = 60/diff(rpeak.old)
#compare number of implausible values
if(length(rpeak.old) > 1 && implausibility(hrtrial) > implausibility(hrtrial.old)) {
r.threshold.initial = r.threshold.initial + 0.01
r.threshold = r.threshold.old #keep old threshold (fewer mistakes)
rpeak = rpeak.old
hrtrial = hrtrial.old
break
}
}
}
}
problem = 1 #just to implement do-while loop
showThis = showAll
while (showThis || problem) {
# if (allrpeak.list[[toString(i)]] %>% is.null() %>% !. && !reassign) rpeak = allrpeak.list[[toString(i)]]
# else  rpeak = timewind[findpeaks(ecgwind, r.threshold)]
# hrtrial = 60/diff(rpeak)
problem = 0
if (length(hrtrial)==0 ||
min(hrtrial) < minhr || max(hrtrial) > maxhr ||
min(tail(hrtrial / lag(hrtrial), -1)) < minHrChange) {
problem = 1
}
if (showThis || problem) {   # Plot trial and ask for different threshold
# Plot raw data
plot(timewind, ecgwind, type="l", xlab="time (s)", ylab="ECG")
if (problem) box(col="orange",lwd=2)
if (exists("r.threshold")) abline(h=r.threshold, col="blue")
abline(v=rpeak, col="red")
if (showMarkers) abline(v=markerwind, col="purple")
currentTitle = paste0("Subject: ", code, " / Window: ", windowtxt, " (", st," - ", en, " sec)")
title(currentTitle)
# Plot heart rate
bpmRange = range(hrtrial)
if (Inf %in% bpmRange || -Inf %in% bpmRange) { #special case: no rpeak detected by threshold
plot(timewind, ecgwind, type="n", xlab="time (s)", ylab="HR (bpm)", ylim=c(-1, 1))
abline(h=0, col="red", lwd=2)
} else {
plot(timewind, ecgwind, type="n", xlab="time (s)", ylab="HR (bpm)", ylim=bpmRange)
lines(rpeak[2:length(rpeak)], hrtrial, col=c("black","red")[problem+1], lwd=2)
abline(h=c(minhr, maxhr), lty=2)
}
reassign = F #needs to be here since it is used to determine if old rpeaks shall be loaded or peak detection with new threshold
promptText = "New threshold"
if (exists("r.threshold")) promptText = paste0(promptText, " (", round(r.threshold, 2), ")")
promptText = paste0(promptText, ": ")
r.threshold_new = readline(promptText)
invalid = T
while (invalid) {
#if (r.threshold_new=="") {
if (substring(r.threshold_new, 1, 1)=="m") {   # Manual editing
rpeak = manualcheck(timewind, ecgwind, rpeak)
allrpeak.list[[toString(i)]] = rpeak
hrtrial = 60/diff(rpeak)
title(currentTitle)
invalid = F
showThis = T
# print("rpeaks manual")
#} else if (substring(r.threshold_new, 1, 1)=="o") {
} else if (substring(r.threshold_new, 1, 1)=="i") {
hrMod = tail(hrtrial / lag(hrtrial), -1)
hrModProblems = which(hrMod < minHrChange) + 1 #rpeaks AFTER these indices are missing
#hrModProblems = which(hrMod < minHrChange & lead(hrMod) > 1/minHrChange)  + 1 #rpeaks AFTER these indices are missing
print(paste0("Found ", length(hrModProblems), " problems in heart rate modulation:"))
for (p in hrModProblems) {
if (p-1 <= 0 || p+1 > length(hrtrial))
print(paste0("Cannot interpolate on the border of a segment. Change segment length via \"l\" to proceed."))
else { #interpolation algorithm
neighbors.rpeak = rpeak[p+c(0, 1)] #adjacent valid heart beats
neighbors.hr = hrtrial[p+c(-1, 1)] #adjacent valid heart rates not affected by missing beat
missing = min(neighbors.rpeak) + abs(diff(neighbors.rpeak)) * last(neighbors.hr)/sum(neighbors.hr)
rpeak = rpeak %>% c(missing)
}
}
rpeak = rpeak %>% sort()
hrtrial = 60/diff(rpeak)
allrpeak.list[[toString(i)]] = rpeak
#invalid = F; showThis = F; i = i - 1 #workaround to reload
invalid = F
showThis = T
} else if (r.threshold_new=="") {
manualok = TRUE
problem = 0   # Manual acceptance
invalid = F
showThis = F
allrpeak.list[[toString(i)]] = rpeak
} else if (substring(r.threshold_new, 1, 1)=="b") {
problem = 0
invalid = F
showThis = F
allrpeak.list[[toString(i)]] = rpeak
} else if (substring(r.threshold_new, 1, 1)=="s") {
name = paste0(path.screenshots, code, " ", i, " @", segment.length, ".png")
print(paste("Saving Screenshot to:", name))
dev.copy(png, file=name, width=1920, height=1080); dev.off(); dev.set(mainWindow)
} else if (substring(r.threshold_new, 1, 1)=="f") {
problem = 0
invalid = F
showThis = F
finishFlag = T
allrpeak.list[[toString(i)]] = rpeak
} else if (substring(r.threshold_new, 1, 1)=="t") {
showMarkers = !showMarkers
print(paste0("showing markers: ", showMarkers))
invalid = F
showThis = T
} else if (substring(r.threshold_new, 1, 1)=="-") {
data$ECG = -data$ECG
ecgwind = -ecgwind
if (exists("r.threshold")) rm("r.threshold")
invalid = F
showThis = T
} else if (substring(r.threshold_new, 1, 1)=="j") {
jumpTo = readline("Jump to segment: ") %>% as.integer()
while (jumpTo %>% is.na()) {
print(paste0("Error. Cannot read new segment: ", jumpTo))
jumpTo = readline("Jump to segment: ") %>% as.integer()
}
problem = 0
invalid = F
showThis = F
} else if (substring(r.threshold_new, 1, 1)=="l") {
input = readline("Change segment length (seconds): ")
while (input %>% as.integer() %>% is.na()) {
print(paste0("Error. Cannot read new segment length: ", jumpTo))
input = readline("Change segment length (seconds): ")
}
segment.length = input %>% as.integer()
allrpeak.list[[toString(i)]] = rpeak
analysis.sequence = seq(scorest, scoreen, segment.length)
i = which(analysis.sequence <= st) %>% last()
allrpeak = allrpeak.list %>% unlist() %>% unname() %>% unique() %>% sort()
allrpeak.list = list()
for (ii in seq(analysis.sequence)) {
st.ii = analysis.sequence[ii]
en.ii = {st.ii + segment.length} %>% c(max(timeline)) %>% min()
allrpeak.list[[toString(ii)]] = allrpeak[allrpeak >= st.ii & allrpeak < en.ii]
}
rpeak = allrpeak.list[[toString(i)]]
hrtrial = 60/diff(rpeak)
st = analysis.sequence[i]
en = {st + segment.length} %>% c(max(timeline)) %>% min()
timewind = timeline[timeline>=st & timeline<en]
ecgwind  = data$ECG[timeline>=st & timeline<en]
problem = 0
invalid = F
showThis = T
#showThis = F; i = i - 1 #workaround to reload
} else { #no keyword, so new threshold provided as numeric
r.threshold_new = tryCatch(as.numeric(r.threshold_new), error=NA)
invalid = is.na(r.threshold_new)
reassign = !invalid
}
if (invalid) {
if (r.threshold_new %in% commandList == F)
print(paste0("Error. Cannot read new threshold: ", r.threshold_new))
r.threshold_new = readline(paste0("New threshold (",
ifelse(exists("r.threshold"), round(r.threshold, 2), ""),
"): "))
} else if (reassign) {
r.threshold = as.numeric(r.threshold_new)
rpeak = timewind[findpeaks(ecgwind, r.threshold)]
# print("rpeaks created 4")
hrtrial = 60/diff(rpeak)
allrpeak.list[[toString(i)]] = rpeak
}
}
}
#allrpeak.list[[toString(i)]] = rpeak
}
#allrpeak.list[[toString(i)]] = rpeak
if (exists("r.threshold_new")==F || substring(r.threshold_new, 1, 1) != "j") jumpTo = i + 1 #jumpTo has to exist even if not evaluated :/
i = case_when(
showAll && substring(r.threshold_new, 1, 1) == "b" ~ {i - 1} %>% c(1) %>% max(),
showAll && substring(r.threshold_new, 1, 1) == "j" ~ jumpTo %>% c(1) %>% max(),
TRUE ~ i + 1)
if (showAll==F) cat(".")
}
cat("\n")
allrpeak = allrpeak.list %>% unlist() %>% unname() %>% unique() %>% sort()
# allrpeak = numeric()
# for (i in seq(allrpeak.list)) allrpeak = c(allrpeak, allrpeak.list[[toString(i)]])
# Delete duplicates
keep = c(TRUE, diff(allrpeak) > 60/maxhr/2)
if (sum(!keep)>0) print(paste0(sum(!keep), " duplicate(s) found and bigger voltage kept (heartrate > ", 2 * maxhr, ")"))
doubleR = which(!keep)
keepLater = data$ECG[which(timeline %in% allrpeak[doubleR])] > data$ECG[which(timeline %in% allrpeak[doubleR - 1])]
keep[doubleR] = keepLater; keep[doubleR-1] = !keepLater
allrpeak = allrpeak[keep]
# Interpolate extrasystoles
allHr = 60/diff(allrpeak)
allHrMod = tail(allHr / lag(allHr), -1)
hrModProblems = which(allHrMod < minHrChange & lead(allHrMod) > 1/minHrChange) + 1 #rpeaks AFTER these indices are missing
interpolate = T
while (length(hrModProblems) > 0 && interpolate) {
print(paste0("Found ", length(hrModProblems), " problems in heart rate modulation:"))
allrpeak[hrModProblems] %>% sapply(function(x) return({x > analysis.sequence} %>% which() %>% tail(1))) %>%
paste0("Segment ", ., " (of ", length(analysis.sequence), ")")
interpol = readline("Shall problems be solved by interpolation? (\"y\" to interpolate) ")
if (substring(interpol, 1, 1)!="y") {
interpolate = F
} else {
for (i in hrModProblems) {
#allHr[i] #this value is too low because beat is missing between
#allrpeak[i+0:1]
#missing = mean(allrpeak[i+0:1]) #interpolate by mean time (i.e., allHr = constant; hrMod == 1)
#interpolate by mean heart rate
missingHr = mean(allHr[i+c(-1, 1)])
missing = allrpeak[i] + 60/missingHr
#weighted average according to bpm #doesn't work well
# weights = {allHr[i-1] / (allHr[i+c(-1, 1)] %>% sum())} %>% c(., {1 - .})
# #sum(weights) #must be 1
# missing = weighted.mean(allrpeak[i+0:1], weights)
allrpeak = allrpeak %>% c(missing)
}
allrpeak = allrpeak %>% sort()
allHr = 60/diff(allrpeak)
allHrMod = tail(allHr / lag(allHr), -1)
hrModProblems = which(allHrMod < minHrChange & lead(allHrMod) > 1/minHrChange) + 1 #rpeaks AFTER these indices are missing
}
}
# Save positions of R-peaks
out = data.frame(rpeaks = allrpeak)
write.csv2(out, code %>% paste0(path.rpeaks, ., path.rpeaks.postfix), row.names=FALSE, quote=FALSE)
dev.off()
}
warnings()
# Read & Score HR --------------------------------------------------------------------
vpn.ecg.rpeaks = list.files("../Physio/Peak_Export/", pattern=path.rpeaks.postfix, full.names=TRUE)
hr.list = list() #vector("list", length(vpn.ecg.rpeaks))
for (vpi in seq(vpn.ecg.rpeaks)) {
vp = vpn.ecg.rpeaks[vpi]
#if (vp %>% pathToCode() %>% codeToNum() %in% exclusions.hr) next
print(vp %>% pathToCode())
code = vp %>% pathToCode() %>% pathToCode(file.ext = "_") %>% substr(1, 6)
#ratingfile = ratings.all %>% filter(subject == code %>% codeToNum())
#load r peaks
allrpeak = read.csv2(vp)[, 1] #only first column
hr = 60/diff(allrpeak) #convert to bpm
#load triggers
trigger <-  read.table(paste0("../Physio/HR/",code,".txt")) %>% .$V3 #lade triggerspalte von HR file mit 0er und marker
trigger <- ifelse(trigger > 8,0,trigger)
if (exclusions.phys.trials[[code]] %>% is.null() == F) { #exclude trials manually (cp. triggerCheck)
triggers.only = trigger[trigger != 0]
toExclude = exclusions.phys.trials[[code]]
triggers.only[toExclude] = 0
trigger[trigger != 0] = triggers.only
}
triggers.n = sum(trigger!=0)
#exclude first wrong triggers for VP6
# if(triggers.n > 180) {
#    trigger[head(which(trigger > 0),16)] <- 0
#    triggers.n = sum(trigger!=0)
#  }
conditions = trigger[trigger!=0]
timeline = seq(trigger) / sample.rate
marker = timeline[{trigger != 0} %>% which() %>% tail(trials.n)]
missingBegin = min(marker) + min(scaling.window); missingBegin = missingBegin[missingBegin <= 0] # <= 0 because first sample point is 1 / sample.rate, i.e. 0 is out of range
missingEnd = max(timeline) - (max(marker) + max(scaling.window)); missingEnd = missingEnd[missingEnd < 0] # < 0 because if difference exactly 0, then last sample point in rage
#check if data is missing at the edges of data
if (!is_empty(missingBegin)) warning(paste(code, ": Lacking data at BEGINNING", -missingBegin, "sec"))
if (!is_empty(missingEnd)) warning(paste(code, ": Lacking data at END", -missingEnd, "sec"))
#check for plausiblilty and issue warning
if (min(hr) < minhr || max(hr) > maxhr) warning(paste(code, ": Implausible heart rate", hr %>% min() %>% round(1), "-", hr %>% max() %>% round(1)))
hr = c(NA, hr) #matching allrpeak[i] to hr[i] (heart rate values only valid if PREVIOUS r peak exists)
# Real time scoring
allhr = numeric()
for (trial in seq(marker)) {
mtime = marker[trial]
hr_t = allrpeak - mtime #heart rate time (relative to marker)
# Real time scaling
hrtrial = numeric()
for (j in seq(scaling.window)[-1]) { #for all indices except for the first (due to j-1 indexing)
current = ifelse(mtime + scaling.window[j] < 0, NA, #skip marker time points that refer to negative times (i.e. out of data)
scaleHR(hr_t, hr, scaling.window[j-1], scaling.window[j]))
hrtrial = c(hrtrial, current)
}
allhr = rbind(allhr, hrtrial)
}
deltaval = allhr - matrix(allhr[, 1], nrow=nrow(allhr), ncol=ncol(allhr))
#ratings.conditions = ratingfile$condition %>% tail(marker %>% length())
#shocks = ratingfile$shock == "True" %>% tail(n=trials.n)
out = data.frame(trial = 1:trials.n, condition = conditions,
#shock = shocks, shockPrior = c(FALSE, lag(shocks)[-1]),
hrbl = allhr[, 1], hr = deltaval[, 2:ncol(deltaval)])
hr.list[[code]] = out
#write.csv2(out, paste(savepath.ecg, code,"_task.csv",sep=""), row.names=FALSE, quote=FALSE)
}
#list to one giant dataframe
heart.wide = hr.list %>% bind_rows(.id="subject") %>%
mutate(subject = subject %>% gsub("\\D", "", .) %>% as.integer()) %>% tibble() %>%
group_by(subject, condition) %>% mutate(trial_condition = 1:n()) %>% ungroup() %>% select(subject, trial, condition, trial_condition, everything())
rm(hr.list); row.names(heart.wide) = NULL
heart = heart.wide %>% gather(key="time", value="HRchange", matches("hr\\.\\d+")) %>% tibble() %>%
mutate(time = time %>% gsub("hr.", "", .) %>% as.integer() %>% {. / 2} %>% as.factor(),
condition = as.factor(condition))
heart.data <- heart.wide %>% mutate(ID = paste0("gca",str_pad(subject,2,pad="0"))) %>% select(ID, trial, hrbl:hr.20)
#plot hr change over trial time with factor threat
heart %>%
filter(condition %in% c(1,2,3,4)) %>%
group_by(condition, time) %>%
summarise(HRchange.se = sd(HRchange, na.rm=T)/sqrt(n()), HRchange = mean(HRchange, na.rm=T)) %>%
mutate(time = time %>% as.character() %>% as.numeric()) %>%
bind_rows(data.frame(condition=unique(heart %>% filter(condition %in% c(1,2,3,4)) %>% .$condition), time=0, HRchange=0, HRchange.se=0)) %>% #add origin
ggplot(aes(x=time-0.5,y=HRchange, fill = condition)) +
#geom_rect(aes(xmin=4, xmax=6, ymin=-2, ymax=1), fill = "deepskyblue1", alpha=0.03) +
geom_errorbar(aes(ymin=HRchange-HRchange.se,ymax=HRchange+HRchange.se), width=0.2)+
geom_line()+
geom_point(size=3, shape=21)+
#scale_fill_manual(values=c("red","orange","darkgreen"), label = c("Threat","Flight","Safety")) +
scale_x_continuous(name ="Time [s]", breaks = c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)) +
scale_y_continuous(name="Heart rate change [bpm]")+
theme_classic() +
theme(legend.position=c(0.15,0.18),
legend.title = element_blank(),
#panel.grid.major.y = element_line(size=0.5, color="#DDDDDD")
)
heart %>%
filter(condition %in% c(5,6,7,8)) %>%
group_by(condition, time) %>%
summarise(HRchange.se = sd(HRchange, na.rm=T)/sqrt(n()), HRchange = mean(HRchange, na.rm=T)) %>%
mutate(time = time %>% as.character() %>% as.numeric()) %>%
bind_rows(data.frame(condition=unique(heart %>% filter(condition %in% c(5,6,7,8)) %>% .$condition), time=0, HRchange=0, HRchange.se=0)) %>% #add origin
ggplot(aes(x=time-0.5,y=HRchange, fill = condition)) +
#geom_rect(aes(xmin=4, xmax=6, ymin=-2, ymax=1), fill = "deepskyblue1", alpha=0.03) +
geom_errorbar(aes(ymin=HRchange-HRchange.se,ymax=HRchange+HRchange.se), width=0.2)+
geom_line()+
geom_point(size=3, shape=21)+
#scale_fill_manual(values=c("red","orange","darkgreen"), label = c("Threat","Flight","Safety")) +
scale_x_continuous(name ="Time [s]", breaks = c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)) +
scale_y_continuous(name="Heart rate change [bpm]")+
theme_classic() +
theme(legend.position=c(0.15,0.18),
legend.title = element_blank(),
#panel.grid.major.y = element_line(size=0.5, color="#DDDDDD")
)
#plot hr change over trial time with factor threat
heart %>%
filter(condition %in% c(1,2,3,4)) %>%
group_by(condition, time) %>%
summarise(HRchange.se = sd(HRchange, na.rm=T)/sqrt(n()), HRchange = mean(HRchange, na.rm=T)) %>%
mutate(time = time %>% as.character() %>% as.numeric()) %>%
bind_rows(data.frame(condition=unique(heart %>% filter(condition %in% c(1,2,3,4)) %>% .$condition), time=0, HRchange=0, HRchange.se=0)) %>% #add origin
ggplot(aes(x=time-0.5,y=HRchange, fill = condition)) +
#geom_rect(aes(xmin=4, xmax=6, ymin=-2, ymax=1), fill = "deepskyblue1", alpha=0.03) +
geom_errorbar(aes(ymin=HRchange-HRchange.se,ymax=HRchange+HRchange.se), width=0.2)+
geom_line()+
geom_point(size=3, shape=21)+
#scale_fill_manual(values=c("red","orange","darkgreen"), label = c("Threat","Flight","Safety")) +
scale_x_continuous(name ="Time [s]", breaks = c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)) +
scale_y_continuous(name="Heart rate change [bpm]")+
theme_classic() +
theme(legend.position=c(0.15,0.18),
legend.title = element_blank(),
#panel.grid.major.y = element_line(size=0.5, color="#DDDDDD")
)
heart %>%
filter(condition %in% c(5,6,7,8)) %>%
group_by(condition, time) %>%
summarise(HRchange.se = sd(HRchange, na.rm=T)/sqrt(n()), HRchange = mean(HRchange, na.rm=T)) %>%
mutate(time = time %>% as.character() %>% as.numeric()) %>%
bind_rows(data.frame(condition=unique(heart %>% filter(condition %in% c(5,6,7,8)) %>% .$condition), time=0, HRchange=0, HRchange.se=0)) %>% #add origin
ggplot(aes(x=time-0.5,y=HRchange, fill = condition)) +
#geom_rect(aes(xmin=4, xmax=6, ymin=-2, ymax=1), fill = "deepskyblue1", alpha=0.03) +
geom_errorbar(aes(ymin=HRchange-HRchange.se,ymax=HRchange+HRchange.se), width=0.2)+
geom_line()+
geom_point(size=3, shape=21)+
#scale_fill_manual(values=c("red","orange","darkgreen"), label = c("Threat","Flight","Safety")) +
scale_x_continuous(name ="Time [s]", breaks = c(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)) +
scale_y_continuous(name="Heart rate change [bpm]")+
theme_classic() +
theme(legend.position=c(0.15,0.18),
legend.title = element_blank(),
#panel.grid.major.y = element_line(size=0.5, color="#DDDDDD")
)
